人们常说，“阅读源代码”是学习编程的一种重要方法。作为程序员，我们在平时的学习工作中，都应该阅读过不少源代码。但是对于大多数人来说，阅读的可能更多是一些代码片断、示例，或者在老师、同事的指导下，先对要阅读的项目代码有了整体的了解之后，再进行针对性的阅读。

但是如果我们面对的是一个像比原这样比较庞大的项目，身边又没有人指导，只能靠自己去看，这时应该怎么来阅读呢？也许每个人也都能找到自己的办法，或高效，或低效，或放弃。

我在这次阅读比原源代码的过程中，尝试的是这样一种方法：从外部入手，通过与比原节点进行数据交互，来一步步了解比原的内部原理。就像剥石榴一样，一点点小心翼翼的下手，最后才能吃到鲜美的果肉。

所以这个文章系列叫作“剥开比原看代码”。

说明
---

在系列中的每一章，我通常都会由一个或者几个相关的问题入手，然后通过对源代码进行分析，来说明比原的代码是如何实现的。对于与当前问题关系不大的代码，则会简单带过，等真正需要它们出场的时候再详细解说。

为了保证文章中引用代码的稳定性，我将基于比原的v1.0.1代码进行分析。随着时间推移，比原的代码也将快速更新，但是我觉得，只要把这个版本的代码理解了，再去看新的代码，应该是一件很容易的事情。

在文章中，将会有一些直接指向github上bytom源代码的链接。为了方便，我专门将bytom v1.0.1的代码放到了一个新的仓库中，这样就不容易与比原官方的最新代码混淆。该仓库地址为：<https://github.com/freewind/bytom-v1.0.1>

当然，你不必clone这个仓库，而是clone官方仓库<http://github.com/Bytom/bytom>，然后在必要的时候，使用以下命令将代码切换到`v1.0.1`的tag，以便与本文一致：

```
git fetch
git checkout -b v1.0.1
```

本篇问题
------

不论采用哪种阅读方法，我想第一步都应该先在本地把比原节点跑起来，试试各种功能。

所以本篇将围绕以下几个问题：

1. 比原初始化时把配置文件保存在哪个目录
2. 比原节点启动后监听的端口是多少
3. 比原启动后，它怎么知道去哪里去找别的节点
4. 比原把密钥和下载的链数据保存在哪个目录
5. 比原用了什么数据库
6. 怎么知道链更新的情况，以及当前更新到什么高度了
7. 怎么知道我连上了多少个节点

对于如何下载、配置和安装的问题，请直接参看官方文档<https://github.com/Bytom/bytom/tree/v1.0.1>（注意我这里给出的是v1.0.1的文档），这里不多说。

这里假设你已经成功地在本地把比原运行起来了，并且在自己喜欢的编辑器中（我个人喜欢IntelliJ的Goland）打开了比原的源代码。

下面我将结合源代码，来回答上面一系列问题。

1. 比原初始化时把配置文件保存在哪个目录
---------------------------------

当我们本地使用`make bytomd`编译完比原后，我们可以使用下面的命令来进行初始化：

```
./bytomd init --chain_id testnet
```

这里指定了使用的chain是`testnet`，运行成功后，它将会在本地文件系统生成一些配置文件，那么会放在哪里呢？

对应的代码位于[config/config.go#L190-L205](https://github.com/freewind/bytom-v1.0.1/blob/master/config/config.go#L190-L205)：

```go
func DefaultDataDir() string {
	// Try to place the data folder in the user's home dir
	home := homeDir()
	dataDir := "./.bytom"
	if home != "" {
		switch runtime.GOOS {
		case "darwin":
			dataDir = filepath.Join(home, "Library", "Bytom")
		case "windows":
			dataDir = filepath.Join(home, "AppData", "Roaming", "Bytom")
		default:
			dataDir = filepath.Join(home, ".bytom")
		}
	}
	return dataDir
}
```

可以看到，在不同的操作系统上，数据目录的位置也不同：

1. 苹果系统(`darwin`)：`~/Library/Bytom`
2. Windows(`windows`): `~/AppData/Roaming/Bytom`
3. 其它（如Linux）：`~/.bytom`

我们根据自己的操作系统打开相应的目录（我的是`~/AppData/Roaming/Bytom`），可以看到有一个`config.toml`，内容大约如下：

```
~/L/Bytom $ cat config.toml
# This is a TOML config file.
# For more information, see https://github.com/toml-lang/toml
fast_sync = true
db_backend = "leveldb"
api_addr = "0.0.0.0:9888"
chain_id = "testnet"
[p2p]
laddr = "tcp://0.0.0.0:46656"
seeds = "47.96.42.1:46656,172.104.224.219:46656,45.118.132.164:46656"
```

它已经把一些基本信息告诉我们了，比如：
- `db_backend = "leveldb"`：说明比原内部使用了leveldb作为数据库（用来保存块数据、帐号、交易信息等）
- `api_addr = "0.0.0.0:9888"`：我们可以在浏览器中打开`http://localhost:9888`来访问dashboard页面，进行查看与管理
- `chain_id = "testnet"`：当前连接的是`testnet`，即测试网，里面挖出来的比原币是不值钱的
- `laddr = "tcp://0.0.0.0:46656"`：本地监听`46656`端口，别的节点如果想连我，就需要访问我的`46656`端口
- `seeds = "47.96.42.1:46656,172.104.224.219:46656,45.118.132.164:46656"`：比原启动后，会主动连接这几个地址获取数据

我们知道比原在初始化时，可以使用不同的`chain_id`去连接不同的网络，也会生成不同内容的配置文件，那么它们对应的源代码是什么样的呢？

原来在[config/toml.go#L22-L45](https://github.com/freewind/bytom/blob/f6d6613a3601f31cd49a32be453e2ec02cf01da9/config/toml.go#L22-L45)：

```go
var defaultConfigTmpl = `# This is a TOML config file.
# For more information, see https://github.com/toml-lang/toml
fast_sync = true
db_backend = "leveldb"
api_addr = "0.0.0.0:9888"
`

var mainNetConfigTmpl = `chain_id = "mainnet"
[p2p]
laddr = "tcp://0.0.0.0:46657"
seeds = "45.79.213.28:46657,198.74.61.131:46657,212.111.41.245:46657,47.100.214.154:46657,47.100.109.199:46657,47.100.105.165:46657"
`

var testNetConfigTmpl = `chain_id = "testnet"
[p2p]
laddr = "tcp://0.0.0.0:46656"
seeds = "47.96.42.1:46656,172.104.224.219:46656,45.118.132.164:46656"
`

var soloNetConfigTmpl = `chain_id = "solonet"
[p2p]
laddr = "tcp://0.0.0.0:46658"
seeds = ""
`
```

可以看到，原来这些端口号和seed的地址，都是事先写好在模板里的。

而且，通过观察这些配置，我们可以发现，如果`chain_id`不同，则监听的端口和连接的种子都不同：

1. mainnet（连接到主网）: `46657`，会主动连接6个种子
2. testnet（连接到测试网）: `46656`，会主动连接3个种子
3. solonet（本地单独节点）: `46658`，不会主动连接别人（也因此不会被别人连接上），适合单机研究

对于已经生成的配置文件，我们可以手动修改其内容，也可以把它删除（或者改名），然后重新使用`bytomd init`生成新的配置文件。

2. 比原节点启动后监听的端口是多少
----------------------------

通过上面的配置文件，我们已经知道比原在不同的chain_id配置下，会监听不同的端口。那么在代码中，它是怎么监听的呢？

